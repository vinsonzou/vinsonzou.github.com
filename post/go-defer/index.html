<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>[Go] defer学习 - cloudSky's 小站</title><meta name=Description content="Linux运维"><meta property="og:title" content="[Go] defer学习"><meta property="og:description" content="在 Go 语言中使用 defer 关键字可以将代码延迟到函数结束之前执行。在开发中，我们经常使用 defer 关键字完成善后工作，如关闭打开的文件描述符、关闭连接以及释放"><meta property="og:type" content="article"><meta property="og:url" content="https://ops.m114.org/post/go-defer/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-20T14:02:03+08:00"><meta property="article:modified_time" content="2023-05-20T14:02:03+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Go] defer学习"><meta name=twitter:description content="在 Go 语言中使用 defer 关键字可以将代码延迟到函数结束之前执行。在开发中，我们经常使用 defer 关键字完成善后工作，如关闭打开的文件描述符、关闭连接以及释放"><meta name=application-name content="cloudSky's 小站"><meta name=apple-mobile-web-app-title content="cloudSky's 小站"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://ops.m114.org/post/go-defer/><link rel=prev href=https://ops.m114.org/post/go-channel-blocking-of-stepping-pit-series/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[Go] defer学习","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ops.m114.org\/post\/go-defer\/"},"genre":"posts","keywords":"Golang","wordcount":1559,"url":"https:\/\/ops.m114.org\/post\/go-defer\/","datePublished":"2023-05-20T14:02:03+08:00","dateModified":"2023-05-20T14:02:03+08:00","publisher":{"@type":"Organization","name":"CloudSky"},"author":{"@type":"Person","name":"CloudSky"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e)}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="cloudSky's 小站">cloudSky's 小站</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class='fa fa-list fa-fw'></i> 所有文章 </a><a class=menu-item href=/tags/><i class='fa fa-tags fa-fw'></i> 标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/links/><i class='fa fa-link fa-fw'></i> </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="cloudSky's 小站">cloudSky's 小站</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title><i class='fa fa-list fa-fw'></i>所有文章</a><a class=menu-item href=/tags/ title><i class='fa fa-tags fa-fw'></i>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/links/ title><i class='fa fa-link fa-fw'></i></a><a href=# onclick=return!1 class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">[Go] defer学习</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=https://ops.m114.org title=Author target=_blank rel="noopener noreffer author" class=author>CloudSky</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/golang/><i class="far fa-folder fa-fw"></i>golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-05-20>2023-05-20</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2023-05-20>2023-05-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 1559 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#0x01先进后出>0x01：先进后出</a></li><li><a href=#0x02作用域仅为当前函数>0x02：作用域仅为当前函数</a></li><li><a href=#0x03defer-后的函数形参在声明时确认预计算参数>0x03：defer 后的函数形参在声明时确认（预计算参数）</a></li><li><a href=#0x04return-先-defer-后>0x04：return 先 defer 后</a></li><li><a href=#0x05panic-捕获防止奔溃>0x05：panic 捕获，防止奔溃</a></li></ul></nav></div></div><div class=content id=content><p>在 Go 语言中使用 <code>defer</code> 关键字可以将代码延迟到函数结束之前执行。在开发中，我们经常使用 defer 关键字完成善后工作，如关闭打开的文件描述符、关闭连接以及释放资源等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo0</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fileName</span> <span class=o>:=</span> <span class=s>&#34;./demo.txt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>OpenFile</span><span class=p>(</span><span class=nx>fileName</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nx>O_RDONLY</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>contents</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>contents</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>defer</code> 关键字一般紧跟在打开资源代码的后面，防止后续忘记释放资源，defer 声明的代码实际上要等到函数结束之前才会被执行。defer 虽然简单易用，但如果忽略了它的特性，就会在开发中面临困惑。针对实际使用中，defer 出现的各种场景，直接上 demo，便于理解。</p><h2 id=0x01先进后出>0x01：先进后出</h2><p>使用多个 defer 关键字时，先被声明的 defer 语句后被调用。类似于 “栈” 先进后出的特性，defer 的这一特性也很好理解，先被打开的资源，可能会被后续代码依赖，所以要后释放才安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// defer: 4
</span></span></span><span class=line><span class=cl><span class=c1>// defer: 3
</span></span></span><span class=line><span class=cl><span class=c1>// defer: 2
</span></span></span><span class=line><span class=cl><span class=c1>// defer: 1
</span></span></span><span class=line><span class=cl><span class=c1>// defer: 0
</span></span></span></code></pre></div><h2 id=0x02作用域仅为当前函数>0x02：作用域仅为当前函数</h2><p>运行 demo2 ，从结果中可以看出，第一个匿名函数和第二个匿名函数的 defer 执行顺序没有关系。
defer 作用域仅为当前函数，在当前函数最后执行，所以不同函数下拥有不同的 defer 栈。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;=== 测试 ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1>// === 测试 ===
</span></span></span><span class=line><span class=cl><span class=c1>// b
</span></span></span><span class=line><span class=cl><span class=c1>// a
</span></span></span></code></pre></div><h2 id=0x03defer-后的函数形参在声明时确认预计算参数>0x03：defer 后的函数形参在声明时确认（预计算参数）</h2><p>运行 demo3_1 ，根据结果，我们可以得出：defer 在声明时，就已经确认了形参 n 的值，而不是在执行时确认的；所以，后续变量 num 无论如何改变都不影响 defer 的输出结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo3_1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>num</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer:&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 等同 defer fmt.Println(&#34;defer:&#34;, num)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//10
</span></span></span><span class=line><span class=cl><span class=c1>//defer: 0
</span></span></span></code></pre></div><p>运行 demo3_2，为什么这里 defer 的最终输出的结果会和变量 num 相同？因为这里使用的是指针。
defer 声明时，已经确认了形参 p 指针的指向地址，指向变量 num；后续变量 num 发生改变。所以在 defer 执行时，输出的是 p 指针指向的变量 num 的当前值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo3_2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>num</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>num</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer:&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>*</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//10
</span></span></span><span class=line><span class=cl><span class=c1>//defer: 10
</span></span></span></code></pre></div><p>再看一下 demo3_3，defer 打印的变量并没有通过函数参数传入，在 defer 执行时，才获取的”全局变量”num，所以 defer 输出结果与变量 num 一致。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo3_3</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>num</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer:&#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 10
</span></span></span><span class=line><span class=cl><span class=c1>// defer: 10
</span></span></span></code></pre></div><h2 id=0x04return-先-defer-后>0x04：return 先 defer 后</h2><p>运行 demo4_1，可以发现 defer、return 都是在函数最后执行，但 return 先于 defer 执行；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo4_1</span><span class=p>()</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;return&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// return
</span></span></span><span class=line><span class=cl><span class=c1>// defer
</span></span></span></code></pre></div><p>这一点从输出结果上显而易见，但当 return、defer 的执行顺序和<strong>函数返回值</strong>“相遇” 时，又将会产生许多复杂的场景。
在 demo4_2 中，函数使用命名返回值，最终输出结果为 7。其中经历了这几个过程：</p><p>（首先）变量 num 作为返回值，初始值为 0；</p><p>（其次）随后变量 num 被赋值为 10；</p><p>（然后）return 时，变量 num 作为返回值被重新赋值为 2；</p><p>（接着）defer 在 return 后执行，拿到变量 num 进行修改，值为 7；</p><p>（最后）变量 num 作为返回值，最终函数返回结果为 7；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo4_2</span><span class=p>()</span> <span class=p>(</span><span class=nx>num</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>num</span> <span class=p>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>num</span> <span class=o>+=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 7
</span></span></span></code></pre></div><p>再来看一个例子。
在 demo4_3 中，函数使用匿名返回值，最终结果输出为 2。其中经历的过程是这样的：</p><p>进入函数，此时返回值变量并未创建；</p><p>创建变量 num，赋值为 10；</p><p>return 时创建函数返回值变量，并赋值为 2；这个返回值变量你可以把它看成匿名变量，或者是变量 a、b、c、d……，但它就不是变量 num；</p><p>defer 时，无论怎样修改变量 num，都与函数返回值无关；</p><p>所以，最终的函数返回结果为 2；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo4_3</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>num</span> <span class=o>:=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>num</span> <span class=o>+=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2
</span></span></span></code></pre></div><h2 id=0x05panic-捕获防止奔溃>0x05：panic 捕获，防止奔溃</h2><p>运行 demo5_1，可以看到当出现 panic 时，会触发已经声明的 defer 出栈执行，随后在再 panic，而在 panic 之后声明的 defer 将得不到执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo5_1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;异常触发&#34;</span><span class=p>)</span> <span class=c1>// 触发 defer 出栈执行
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=c1>// 得不到执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>正是利用这个特性，在 defer 中可以通过 recover 捕获 panic，防止程序崩溃。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>demo5_2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;问题不大&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;异常触发&#34;</span><span class=p>)</span> <span class=c1>// 触发 defer 出栈执行
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-05-20</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=# onclick=return!1 title="分享到 Twitter" data-sharer=twitter data-url=https://ops.m114.org/post/go-defer/ data-title="[Go] defer学习" data-hashtags=Golang><i class="fab fa-twitter fa-fw"></i></a><a href=# onclick=return!1 title="分享到 Facebook" data-sharer=facebook data-url=https://ops.m114.org/post/go-defer/ data-hashtag=Golang><i class="fab fa-facebook-square fa-fw"></i></a><a href=# onclick=return!1 title="分享到 微博" data-sharer=weibo data-url=https://ops.m114.org/post/go-defer/ data-title="[Go] defer学习"><i class="fab fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/golang/>golang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/post/go-channel-blocking-of-stepping-pit-series/ class=prev rel=prev title="[Go] 踩坑系列之channel阻塞"><i class="fas fa-angle-left fa-fw"></i>[Go] 踩坑系列之channel阻塞</a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.111.3">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2014 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://ops.m114.org target=_blank rel="noopener noreferrer">CloudSky</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script></div><div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"vinsonzou/vinsonzou.github.com"}},sharerjs:!0}</script></div></body></html>