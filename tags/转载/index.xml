<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>转载 on ops</title>
    <link>https://ops.m114.org/tags/%E8%BD%AC%E8%BD%BD/index.xml</link>
    <description>Recent content in 转载 on ops</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2014-2018. All rights reserved.</copyright>
    <atom:link href="https://ops.m114.org/tags/%E8%BD%AC%E8%BD%BD/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>analysing java core dump</title>
      <link>https://ops.m114.org/post/analysing-java-core-dump/</link>
      <pubDate>Sun, 23 Jul 2017 16:32:26 +0800</pubDate>
      
      <guid>https://ops.m114.org/post/analysing-java-core-dump/</guid>
      <description>&lt;p&gt;In this post, I will show you how you can debug a Java core file to see what caused your JVM to crash. I will be using a core file I generated in my previous post: &lt;a href=&#34;http://fahdshariff.blogspot.co.uk/2012/08/generating-java-core-dump.html&#34;&gt;Generating a Java Core Dump&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are different ways you can diagnose a JVM crash, listed below:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The hs_err_pid log file&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When a fatal error occurs in the JVM, it produces an error log file called hs_err_pidXXXX.log, normally in the working directory of the process or in the temporary directory for the operating system. The top of this file contains the cause of the crash and the &amp;ldquo;problematic frame&amp;rdquo;. For example, mine shows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ head hs_err_pid21178.log
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x0000002b1d00075c, pid=21178, tid=1076017504
#
# JRE version: 6.0_21-b06
# Java VM: Java HotSpot(TM) 64-Bit Server VM (17.0-b16 mixed mode linux-amd64 )
# Problematic frame:
# C  [libnativelib.so+0x75c]  bar+0x10
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a stack trace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stack: [0x000000004012b000,0x000000004022c000],  sp=0x000000004022aac0,  free space=3fe0000000000000018k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
C  [libnativelib.so+0x75c]  bar+0x10
C  [libnativelib.so+0x772]  foo+0xe
C  [libnativelib.so+0x78e]  Java_CoreDumper_core+0x1a
j  CoreDumper.core()V+0
j  CoreDumper.main([Ljava/lang/String;)V+7
v  ~StubRoutines::call_stub
V  [libjvm.so+0x3e756d]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The stack trace shows that my java method, CoreDumper.core(), called into JNI and died when the bar function was called in native code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Debugging a Java Core Dump&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In some cases, the JVM may not produce a hs_err_pid file, for example, if the native code abruptly aborts by calling the abort function. In such cases, we need to analyse the core file produced. On my machine, the operating system writes out core files to /var/tmp/cores. You can use the following command to see where your system is configured to write out core files to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /proc/sys/kernel/core_pattern
/var/tmp/cores/%e.%p.%u.core
$ ls /var/tmp/cores
java.21178.146385.core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few, different ways to look at core dumps:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Using gdb&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GNU Debugger (gdb) can examine a core file and work out what the program was doing when it crashed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb $JAVA_HOME/bin/java /var/tmp/cores/java.14015.146385.core
(gdb) where
#0  0x0000002a959bd26d in raise () from /lib64/tls/libc.so.6
#1  0x0000002a959bea6e in abort () from /lib64/tls/libc.so.6
#2  0x0000002b1cecf799 in bar () from libnativelib.so
#3  0x0000002b1cecf7a7 in foo () from libnativelib.so
#4  0x0000002b1cecf7c3 in Java_CoreDumper_core () from libnativelib.so
#5  0x0000002a971aac88 in ?? ()
#6  0x0000000040113800 in ?? ()
#7  0x0000002a9719fa42 in ?? ()
#8  0x000000004022ab10 in ?? ()
#9  0x0000002a9a4d5488 in ?? ()
#10 0x000000004022ab70 in ?? ()
#11 0x0000002a9a4d59c8 in ?? ()
#12 0x0000000000000000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The where command prints the stack frames and shows that the bar function called abort() which caused the crash.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Using jstack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jstack prints stack traces of Java threads for a given core file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jstack -J-d64 $JAVA_HOME/bin/java /var/tmp/cores/java.14015.146385.core
Debugger attached successfully.
Server compiler detected.
JVM version is 17.0-b16
Deadlock Detection:

No deadlocks found.

Thread 16788: (state = BLOCKED)

Thread 16787: (state = BLOCKED)
 - java.lang.Object.wait(long) @bci=0 (Interpreted frame)
 - java.lang.ref.ReferenceQueue.remove(long) @bci=44, line=118 (Interpreted frame)
 - java.lang.ref.ReferenceQueue.remove() @bci=2, line=134 (Interpreted frame)
 - java.lang.ref.Finalizer$FinalizerThread.run() @bci=3, line=159 (Interpreted frame)

Thread 16786: (state = BLOCKED)
 - java.lang.Object.wait(long) @bci=0 (Interpreted frame)
 - java.lang.Object.wait() @bci=2, line=485 (Interpreted frame)
 - java.lang.ref.Reference$ReferenceHandler.run() @bci=46, line=116 (Interpreted frame)

Thread 16780: (state = IN_NATIVE)
 - CoreDumper.core() @bci=0 (Interpreted frame)
 - CoreDumper.main(java.lang.String[]) @bci=7, line=12 (Interpreted frame)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. Using jmap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jmap examines a core file and prints out shared object memory maps or heap memory details.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jmap -J-d64 $JAVA_HOME/bin/java /var/tmp/cores/java.14015.146385.core
Debugger attached successfully.
Server compiler detected.
JVM version is 17.0-b16
0x0000000040000000      49K     /usr/sunjdk/1.6.0_21/bin/java
0x0000002a9566c000      124K    /lib64/tls/libpthread.so.0
0x0000002a95782000      47K     /usr/sunjdk/1.6.0_21/jre/lib/amd64/jli/libjli.so
0x0000002a9588c000      16K     /lib64/libdl.so.2
0x0000002a9598f000      1593K   /lib64/tls/libc.so.6
0x0000002a95556000      110K    /lib64/ld-linux-x86-64.so.2
0x0000002a95bca000      11443K  /usr/sunjdk/1.6.0_21/jre/lib/amd64/server/libjvm.so
0x0000002a96699000      625K    /lib64/tls/libm.so.6
0x0000002a9681f000      56K     /lib64/tls/librt.so.1
0x0000002a96939000      65K     /usr/sunjdk/1.6.0_21/jre/lib/amd64/libverify.so
0x0000002a96a48000      228K    /usr/sunjdk/1.6.0_21/jre/lib/amd64/libjava.so
0x0000002a96b9e000      109K    /lib64/libnsl.so.1
0x0000002a96cb6000      54K     /usr/sunjdk/1.6.0_21/jre/lib/amd64/native_threads/libhpi.so
0x0000002a96de8000      57K     /lib64/libnss_files.so.2
0x0000002a96ef4000      551K    /lib64/libnss_db.so.2
0x0000002a97086000      89K     /usr/sunjdk/1.6.0_21/jre/lib/amd64/libzip.so
0x0000002b1cecf000      6K      /home/sharfah/tmp/jni/libnativelib.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Useful Links:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://weblogs.java.net/blog/kohsuke/archive/2009/02/crash_course_on.html&#34;&gt;Crash course on JVM crash analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fahdshariff.blogspot.co.uk/2012/08/generating-java-core-dump.html&#34;&gt;Generating a Java Core Dump&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From &lt;a href=&#34;http://fahdshariff.blogspot.co.uk/2012/08/analysing-java-core-dump.html&#34;&gt;http://fahdshariff.blogspot.co.uk/2012/08/analysing-java-core-dump.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 OpenResty 中使用正则表达式</title>
      <link>https://ops.m114.org/post/use-regular-expressions-in-OpenResty/</link>
      <pubDate>Sun, 30 Oct 2016 10:48:19 +0800</pubDate>
      
      <guid>https://ops.m114.org/post/use-regular-expressions-in-OpenResty/</guid>
      <description>&lt;p&gt;在 OpenResty 中使用正则表达式，社区中推荐的做法是使用ngx.re api。比如匹配一个字符串是否为 http(s) 的链接，可以这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local function is_http_url(s)
    return ngx.re.find(s, [[^https?://[\w-_?.:/+=&amp;amp;#%]+$]])
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;压测一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local t = os.clock()
for _ = 1, max do
    is_http_url(&amp;quot;http://blog.stackoverflow.com/2016/10/Stack-Overflow-92-Podcast-The-Guerilla-Guide-to-Interviewing/?cb=1&amp;quot;)
end
print(&amp;quot;Time cost: &amp;quot;, os.clock() - t, &amp;quot; s&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：Time cost: 2.663408 s&lt;/p&gt;

&lt;p&gt;另一种做法是使用 lua 的正则语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local function is_http_url(s)
    return s:find(&amp;quot;^https?://[%w-_%.%?:/%+=&amp;amp;#%%]+$&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：Time cost: 0.652221 s&lt;/p&gt;

&lt;p&gt;呃，怎么前者耗时是后者的四倍？lua 内置的小小状态机实现，居然打败了大名鼎鼎的 PCRE 库！说好的社区推荐呢！&lt;/p&gt;

&lt;p&gt;仔细一瞧，前者的确漏了点东西。ngx.re默认不会缓存正则表达式编译后的结果。一般在其它编程平台上，我们都会先把字符串编译成正则表达式，再用到正则函数中。比如在
Python 里使用 re.compile。所以赶紧补上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return ngx.re.find(s, [[^https?://[\w-_?.:/+=&amp;amp;#%]+$]], &amp;quot;o&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，这次性能有了明显提升：Time cost: 0.646518 s&lt;/p&gt;

&lt;p&gt;不错不错，虽然还是跟 lua 的实现不分上下，考虑到 lua 本身的正则支持非常弱（比如连 (foo|bar)
这种形式都不行），而且语法离经叛道，改用 ngx.re 还是挺有必要的。毕竟 PCRE 可是 Perl Compatibility Regex
Expression库，我最喜欢它支持的(?name:pattern)形式的命名捕获功能。&lt;/p&gt;

&lt;p&gt;其实 ngx.re 实现尚未用尽全力呢。开启了 JIT 之后，PCRE 库的性能会更上一层楼：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return ngx.re.find(s, [[^https?://[\w-_?.:/+=&amp;amp;#%]+$]], &amp;quot;jo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：Time cost: 0.421824 s&lt;/p&gt;

&lt;p&gt;此时，lua 正则已经被甩到后面去了。&lt;/p&gt;

&lt;p&gt;还能更快吗？&lt;/p&gt;

&lt;p&gt;当然，OpenResty 军火库里还有另外一个武器：&lt;a href=&#34;https://github.com/openresty/lua-resty-core&#34;&gt;lua-resty-core&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;resty.core.regex&#39;

local function is_http_url(s)
    return ngx.re.find(s, [[^https?://[\w-_?.:/+=&amp;amp;#%]+$]], &amp;quot;jo&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：Time cost: 0.175346 s&lt;/p&gt;

&lt;p&gt;Boom！最终用时是 lua 正则的四分之一。lua 正则已经望尘莫及了。有趣的是，这个结果正好是第一次比较的结果倒过来。
实话说，这个结果在我的意料之外。resty.core.regex 版本的 ngx.re api，跟默认版本的区别在于对入参和出参的处理是在 lua
代码里完成的，另外调用 C 函数部分采用的是 ffi 而非传统的 C binding。但为什么会这么快？luajit 是否对 ffi 有 jit 优化？&lt;/p&gt;

&lt;p&gt;需要注明一下，resty.core.regex并非银弹。在我们自己的应用上，我尝试引入resty.core.regex，发现对性能无可见的提升。当然，我们的应用的功能不是匹配
url，正则处理亦非瓶颈。不过 resty.core.regex 对自己的项目是否有效，还需要诸君自己测试一番。&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果在 OpenResty 项目中需要使用正则表达式，请使用 ngx.re api，并开启 jo 选项。&lt;/li&gt;
&lt;li&gt;resty.core.regex 值得一试。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文：&lt;a href=&#34;https://segmentfault.com/a/1190000007298100&#34;&gt;https://segmentfault.com/a/1190000007298100&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>